# 剑指offer

# 数据结构
## 数组
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[3. 数组中重复的数字](3.cpp)||数组元素特征，T=O(n)，S=O(1)
[4. 二维数组中的查找](4.cpp)||数组元素特征，T=O(n+m)，S=O(1)
[39. 数组中出现次数超过一半的数字](39.cpp)|简单|数组元素特征（摩尔投票法），T=O(n)，S=O(1)|Hash，T=O(n)，S=O(n)

## 字符串
题目|难度|方法1|方法2|备注
---|---|---|---|---
[5. 替换空格](5.cpp)||遍历+原地修改，T=O(n)，S=O(1)
[20. 表示数值的字符串](20.cpp)|中等|逐字符判断，T=O(n)||方法待优化
[58 - I. 翻转单词顺序](58_1.cpp)|中等|遍历+stack，T=O(n)，S=O(n)
[58 - II. 左旋转字符串](58_2.cpp)|简单|三次反转，T=O(n)，S=O(1)

## 链表
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[6. 从尾到头打印链表](6.cpp)|简单|递归法，T=O(n)|辅助栈，T=O(n)
[18. 删除链表的节点](18.cpp)|简单|双指针，T=O(n)
[22. 链表中倒数第k个节点](22.cpp)|简单|双指针，T=O(n)
[24. 反转链表](24.cpp)|简单|遍历+指针修改，T=O(n)
[25. 合并两个排序的链表](25.cpp)|简单|遍历+指针修改，T=O(n+m)
[35. 复杂链表的复制](35.cpp)|中等|遍历复制+map，T=O(n)，S=O(n)|遍历复制+拆分，T=O(n)，S=O(1)
[52. 两个链表的第一个公共节点](52.cpp)|中等|双指针，T=O(n), S=O(1)

## 树
题目|难度|方法1|方法2|备注
---|---|---|---|---
[27. 二叉树的镜像](27.cpp)|简单|二叉树的先序遍历，T=O(n)
[28. 对称的二叉树](28.cpp)|简单|二叉树的先序遍历，T=O(n)
[32 - I. 从上到下打印二叉树](32_1.cpp)|中等|二叉树的层次遍历，T=O(n)
[32 - II. 从上到下打印二叉树 II](32_2.cpp)|中等|二叉树的层次遍历，T=O(n)
[32 - III. 从上到下打印二叉树 III](32_3.cpp)|中等|二叉树的层次遍历，T=O(n)
[54. 二叉搜索树的第k大节点](54.cpp)|简单|二叉树的中序遍历(dfs)，T=O(n)
[55 - I. 二叉树的深度](55_1.cpp)|简单|二叉树的后序遍历(dfs)，T=O(n)|二叉树的层次遍历(bfs)，T=O(n)
[55 - II. 平衡二叉树](55_2.cpp)|简单|二叉树的先序遍历(dfs)，T=O(nlogn)|二叉树的后序遍历(dfs)，T=O(n)
[68 - I. 二叉搜索树的最近公共祖先](68_1.cpp)|简单|递归法，T=O(n)||*
[68 - II. 二叉树的最近公共祖先](68_2.cpp)|简单|二叉树的后序遍历(dfs)，T=O(n)||*

## 栈和队列
题目|难度|方法1|方法2|备注
---|---|---|---|---
[9. 用两个栈实现队列](9.cpp)|简单
[30. 包含min函数的栈](30.cpp)|简单
[31. 栈的压入、弹出序列](31.cpp)|中等|栈，T=O(n)||用栈+压入序列来模拟弹出序列

## 堆，红黑树
题目|难度|方法1|方法2|方法3|备注
---|---|---|---|---
[40. 最小的k个数](40.cpp)|简单|最大堆，T=O(nlogk)|红黑树，T=O(nlogk)|基于快排的partition函数，T=O(n)|`classic`
[41. 数据流中的中位数](41.cpp)|困难|最大堆+最小堆，T=O(logn)

# 算法
## 排序
题目|难度|方法1|方法2|方法3|备注
---|---|---|---|---
[40. 最小的k个数](40.cpp)|简单|基于快排的partition函数，T=O(n)|最大堆，T=O(nlogk)|红黑树，T=O(nlogk)
[45. 把数组排成最小的数](45.cpp)|中等|排序+自定义优先级，T=O(nlog)

## 二分查找
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[53 - I. 在排序数组中查找数字](53_1.cpp)|简单|二分，T=O(logn)，S=O(1)
[53 - II. 0～n-1中缺失的数字](53_2.cpp)|简单|二分，T=O(logn)，S=O(1)
[11. 旋转数组的最小数字](11.cpp)|困难|二分，T=O(logn)，S=O(1)

## 双指针
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[21. 调整数组顺序使奇数位于偶数前面](21.cpp)|简单|双指针，T=O(n), S=O(1)

## 分治
## 回溯法
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[34. 二叉树中和为某一值的路径](34.cpp)|中等|回溯法，T=O(n)
[38. 字符串的排列](38.cpp)|中等|回溯法，T=O(n!)

## 搜索
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[12. 矩阵中的路径](12.cpp)|中等|搜索(dfs)
[13. 机器人的运动范围](13.cpp)|中等|搜索(dfs)

## 动态规划
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[10- I. 斐波那契数列](10_1.cpp)|简单|DP，T=O(n)
[10- II. 青蛙跳台阶问题](10_2.cpp)|简单|DP，T=O(n)
[42. 连续子数组的最大和](42.cpp)|简单|DP，T=O(n)
[46. 把数字翻译成字符串](46.cpp)|中等|DP，T=O(n), S=O(n)
[47. 礼物的最大价值](47.cpp)|中等|DP，T=O(nm)
[48. 最长不含重复字符的子字符串](48.cpp)|中等|DP，T=O(n), S=O(1)
[63. 股票的最大利润](63.cpp)|中等|DP，T=O(n)

## 贪心
题目|难度|方法1|方法2|备注
---|---|---|---|---
[14- I. 剪绳子](14_1.cpp)|中等|贪心，T=O(n)|DP，T=O(n^2)|尽量剪成3，否则剪成2

## 数学
## 位运算
题目|难度|方法1|方法2|备注
---|---|---|---|---
[15. 二进制中1的个数](15.cpp)|简单|位运算，T=O(32)||n & (n-1)
[56 - I. 数组中数字出现的次数](56_1.cpp)|中等|位运算，T=O(n)||异或
[56 - II. 数组中数字出现的次数 II](56_2.cpp)|中等|位运算，T=O(n*32)||统计每一位1的个数
[65. 不用加减乘除做加法](65.cpp)|简单|位运算，T=O(32)||负数的左移可能会导致error: left shift of negative value

## Hash
题目|难度|方法1|方法2|备注
---|---|---|---|---
[39. 数组中出现次数超过一半的数字](39.cpp)|简单|Hash，T=O(n)，S=O(n)|数组元素特征（摩尔投票法），T=O(n)，S=O(1)
[50. 第一个只出现一次的字符](50.cpp)|简单|Hash，T=O(n)，S=O(26)

## 其他
题目|难度|方法1|方法2|方法3
---|---|---|---|---
[61. 扑克牌中的顺子](61.cpp)|简单|排序，T=O(5)

